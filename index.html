<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>EMOTE â€“ Emotion Detection</title>

<style>
body{
  margin:0;height:100vh;font-family:Arial;
  background:linear-gradient(120deg,#3a1c71,#d76d77,#ffaf7b);
  display:flex;justify-content:center;align-items:center;
  overflow:hidden;
}
.container{
  background:rgba(0,0,0,.75);
  padding:35px;border-radius:20px;width:560px;
  color:#fff;text-align:center;
}
textarea{
  width:100%;height:120px;border-radius:12px;
  border:none;padding:12px;font-size:16px;
}
button{
  margin-top:18px;padding:12px 35px;
  border:none;border-radius:30px;
  background:#ff9800;color:#fff;
  font-weight:bold;cursor:pointer;
}
.result{margin-top:20px;font-size:17px}
.fall{
  position:fixed;top:-40px;font-size:32px;
  animation:fall 3s linear forwards;
}
@keyframes fall{
  from{transform:translateY(0);opacity:1}
  to{transform:translateY(110vh);opacity:0}
}
</style>
</head>

<body>
<div class="container">
  <h2>EMOTE</h2>
  <p>Emotion Detection using GoEmotions Dataset</p>

  <textarea id="inputText" placeholder="Enter one sentence only..."></textarea>
  <button onclick="detectEmotion()">Detect Emotion</button>

  <div class="result" id="output"></div>
</div>

<script>
let dataset=[], loaded=false;

/* ===== NORMALIZE TEXT ===== */
function norm(t){
  return t.toLowerCase()
    .replace(/\bi m\b/g,"i am")
    .replace(/\bim\b/g,"i am")
    .replace(/[^\w\s]/g,"")
    .trim();
}

/* ===== LOAD DATASET ===== */
fetch("goemotions_1.csv")
.then(r=>r.text())
.then(d=>{
  const l=d.trim().split(/\r?\n/);
  const h=l[0].toLowerCase().split(",");
  const ti=h.indexOf("text");
  const ei=h.indexOf("emotion");

  for(let i=1;i<l.length;i++){
    const c=l[i].split(",");
    dataset.push({text:norm(c[ti]),emotion:c[ei].toLowerCase()});
  }
  loaded=true;
});

/* ===== EMOTION STYLE ===== */
const style={
  happy:["#4CAF50","ðŸ˜Š"], sad:["#2196F3","ðŸ˜¢"],
  anger:["#F44336","ðŸ˜¡"], fear:["#9C27B0","ðŸ˜¨"],
  love:["#E91E63","â¤ï¸"], surprise:["#FFC107","ðŸ˜²"],
  disgust:["#795548","ðŸ¤¢"], neutral:["#BDBDBD","ðŸ˜"]
};

/* ===== PREDICT (DATASET ONLY) ===== */
function predict(txt){
  let s={}, w=norm(txt).split(" ");
  dataset.forEach(r=>{
    r.text.split(" ").forEach(x=>{
      if(w.includes(x)){
        s[r.emotion]=(s[r.emotion]||0)+1;
      }
    });
  });
  let b="neutral",m=0;
  for(let e in s){if(s[e]>m){m=s[e];b=e}}
  return b;
}

/* ===== METRICS FROM DATASET ===== */
function metrics(){
  let tp={},fp={},fn={},c=0;
  dataset.forEach(r=>{
    let p=predict(r.text), a=r.emotion;
    tp[a]=tp[a]||0; fp[a]=fp[a]||0; fn[a]=fn[a]||0;
    if(p===a){tp[a]++;c++}
    else{fp[p]=(fp[p]||0)+1;fn[a]++}
  });
  let ps=0,rs=0,fs=0,n=0;
  for(let e in tp){
    let pr=tp[e]/((tp[e]+(fp[e]||0))||1);
    let re=tp[e]/((tp[e]+(fn[e]||0))||1);
    let f1=(2*pr*re)/((pr+re)||1);
    ps+=pr;rs+=re;fs+=f1;n++;
  }
  return {
    acc:(c/dataset.length).toFixed(2),
    p:(ps/n).toFixed(2),
    r:(rs/n).toFixed(2),
    f:(fs/n).toFixed(2)
  };
}

/* ===== FALLING ANIMATION ===== */
function fall(e){
  for(let i=0;i<12;i++){
    let s=document.createElement("span");
    s.className="fall"; s.innerText=style[e][1];
    s.style.left=Math.random()*100+"vw";
    s.style.color=style[e][0];
    document.body.appendChild(s);
    setTimeout(()=>s.remove(),3000);
  }
}

/* ===== MAIN ===== */
function detectEmotion(){
  if(!loaded){alert("Dataset loadingâ€¦");return}
  const t=document.getElementById("inputText").value.trim();
  if(!t)return;
  const e=predict(t), m=metrics();
  document.getElementById("output").innerHTML=`
    <span style="color:${style[e][0]}">
      <b>Predicted Emotion:</b> ${e.toUpperCase()}
    </span><br>
    Accuracy: ${m.acc}<br>
    Precision: ${m.p}<br>
    Recall: ${m.r}<br>
    F1-Score: ${m.f}`;
  fall(e);
}
</script>
</body>
</html>
